#include "LightningGenerator.h"
#include "UObject/ConstructorHelpers.h"
#include "Kismet/GameplayStatics.h"
#include "Kismet/KismetMathLibrary.h"



// Sets default values
ALightningGenerator::ALightningGenerator()
{
 	// Set this actor to call Tick() every frame.
	PrimaryActorTick.bCanEverTick = true;

	// Setting default property values.
	// *** //
	Axiom = "F";
	BranchChance = 0.8;
	TurnChance = 0.7;
	Iterations = 6;
	Speed = 5;
	bAnimateLightning = false;

	bUsePhysicsModel = false;
	PModel.Set3DMode(&bIs3DEnabled);

	ParticleCount = 7;
	LightningColor = { 0.11f, 0.22, 0.49, 1 };
	ParticleLifespan = 1.0f;
	ColorIntensity = 300.0f;
	LSystemJitter = 0.45f;
	PModelJitter = 0.72f;
	SphereScale = { .01f, .01f, .01f };
	SphereLifespanOffset = 2.0f; // prevents sphere particle from leaving visual artefacts by destroying it slightly early.

	LightningDirection = FVector(0, 0, -1);
	DrawPosition = FVector(0, 0, 0);
	MinSegmentLength = 40.0f;
	MaxSegmentLength = 60.0f;
	MinAngleBranch = 25.0f;
	MaxAngleBranch = 40.0f;
	MinAngleTurning = 5.0f;
	MaxAngleTurning = 15.0f;
	MinWidth = 5.0f; // unused, MaxWidth used for shader consistency between models
	MaxWidth = 10.0f;
	BranchWidthMultiplier = 0.66f;

	bIsDrawing = false;
	SegmentsDrawn = 0;

	bAutoGenerate = true;
	SpawnInterval = 2.0f;

	ImGuiScale = 2.0f;
	RenderTime = 0.0f;
	GenerationTime = 0.0f;

	bIs3DEnabled = true;
	bDynamicBranchWidth = false;
	bHideFirstSegment = false;
	// *** //

	// Generate L-system rules using L-system values.
	RebuildRules();

	// Finds the lightning particle file and creates a template object used when spawning the lightning particles.
	static ConstructorHelpers::FObjectFinder<UNiagaraSystem> lightningParticle(TEXT("/Game/LightningParticle"));
	LightningTemplate = lightningParticle.Object;

	
}

void ALightningGenerator::BuildLSystem() 
{
	// Call the L system's build function using the defined axiom, rules and no. of iterations.
	System.Build(Axiom, Rules, Iterations);
}

FString ALightningGenerator::GetString()
{
	// Get the L system's generated string.
	return System.GetResult();
}

// Called when the game starts or when spawned
void ALightningGenerator::BeginPlay()
{
	Super::BeginPlay();

	// Lightning spawned on begin play.
	SpawnLightning();
}

// Counts the number of lightning segments generated by the L-system.
int ALightningGenerator::CountSegments()
{
	int segments = 0;

	// Get the generated string from the L system, converted to an array of chars.
	auto charArray = System.GetResult().GetCharArray();
	
	// Iterate through each char in the array. Every F (forward) counts as a new lightning segment.
	for (int i = 0; i < charArray.Num(); i++)
	{
		if (charArray[i] == 'F')
		{
			segments++;
		}
	}

	return segments;
}

// Draw a segment of the lightning from the L-system. Each segment has it's own small particle system. 
void ALightningGenerator::DrawSegment()
{
	float scale = 4;

	// Generate the length of the segment.
	SegmentLength = FMath::RandRange(MinSegmentLength, MaxSegmentLength);

	// Spawns a lightning particle system. This draws a line between two points, and applies jitter to give it the zig-zaggy lightning look.
	UNiagaraComponent* lightningSegment = UNiagaraFunctionLibrary::SpawnSystemAtLocation(GetWorld(), LightningTemplate, FVector(0, 0, 0));

	// Start position of the segment is the current draw position. End position is start position + the calculated length in the direction the lightning is moving.
	FVector startPos = DrawPosition;
	FVector endPos = startPos + (LightningDirection * SegmentLength);

	// Sets the parameters of the lightning particle system.
	lightningSegment->SetVectorParameter(FName("Start"), startPos);
	lightningSegment->SetVectorParameter(FName("End"), endPos);
	lightningSegment->SetIntParameter(FName("Particles"), ParticleCount);
	lightningSegment->SetFloatParameter(FName("Lifespan"), ParticleLifespan);
	lightningSegment->SetFloatParameter(FName("Jitter"), LSystemJitter);

	// Particle system also contains a sphere mesh appended to the end of the segment to ensure they connect smoothly.
	lightningSegment->SetVectorParameter(FName("SpherePos"), endPos);
	lightningSegment->SetFloatParameter(FName("SphereLifespan"), ParticleLifespan - GetWorld()->GetDeltaSeconds() * SphereLifespanOffset);


	FLinearColor finalColor;

	// If the segment is part of the main branch, use max values for remaining parameters.
	if (SavedPositions.Num() == 0)
	{
		finalColor = LightningColor * ColorIntensity;
		lightningSegment->SetColorParameter(FName("Color"), finalColor);
		lightningSegment->SetFloatParameter(FName("MinWidth"), MaxWidth);
		lightningSegment->SetFloatParameter(FName("MaxWidth"), MaxWidth);
		lightningSegment->SetVectorParameter(FName("SphereScale"), SphereScale * MaxWidth);
	}
	else // If the segment is not in the main branch...
	{
		// If dynamic branch width is enabled, the multiplier will be based on branch depth. Otherwise a fixed value is used.
		float multiplier;
		if (bDynamicBranchWidth)
		{
			multiplier = 1.0f / SavedPositions.Num();
		}
		else
		{
			multiplier = BranchWidthMultiplier;
		}
		
		// Regardless of dynamic branch width, deeper branches will have a less intense colour, resulting in less light being emitted.
		finalColor = LightningColor * ColorIntensity * (0.5f / SavedPositions.Num());
		lightningSegment->SetColorParameter(FName("Color"), finalColor);

		// Multiplier applied for width.
		lightningSegment->SetFloatParameter(FName("MinWidth"), MaxWidth * multiplier);
		lightningSegment->SetFloatParameter(FName("MaxWidth"), MaxWidth * multiplier);
		lightningSegment->SetVectorParameter(FName("SphereScale"), SphereScale * MaxWidth * multiplier);
	}
	
	// Save particles to an array so they can be accessed later, such as if they need to be destroyed early.
	SegmentParticles.Add(lightningSegment);

	// Update the draw position.
	DrawPosition = endPos;
}

// Rotates the lightning segment direction right.
void ALightningGenerator::RotateRight()
{
	float randomAngleX, randomAngleY;

	// Generate random angle and rotator, then apply it to the lightning's direction to rotate it.
	// The main branch and other branches have separate values, as the main branch should turn less.
	if (SavedPositions.Num() == 0)
	{
		randomAngleX = FMath::RandRange(MinAngleTurning, MaxAngleTurning);
		randomAngleY = FMath::RandRange(MinAngleTurning, MaxAngleTurning);
	}
	else
	{
		randomAngleX = FMath::RandRange(MinAngleBranch, MaxAngleBranch);
		randomAngleY = FMath::RandRange(MinAngleBranch, MaxAngleBranch);
	}
	 
	FRotator rotation;

	// Rotation is applied in 2 dimensions if 3D mode is enabled. Otherwise it is just applied in the X dimension.
	if (bIs3DEnabled)
	{
		if (UKismetMathLibrary::RandomBool()) // Random boolean decides with equal chance whether the Y rotation will be forwards or backwards.
		{
			rotation = FRotator(randomAngleX, randomAngleY, 0);
		}
		else
		{
			rotation = FRotator(randomAngleX, -randomAngleY, 0);
		}
	}
	else
	{
		rotation = FRotator(randomAngleX, 0, 0);
	}
	
	// Apply rotation to the lightning's direction.
	LightningDirection = rotation.RotateVector(LightningDirection);
}

// Rotates the lightning segment direction left.
void ALightningGenerator::RotateLeft()
{
	float randomAngleX, randomAngleY; 

	// Generate random angle and rotator (with angle negated), then apply it to the lightning's direction to rotate it.
	// The main branch and other branches have separate values, as the main branch should turn less.
	if (SavedPositions.Num() == 0)
	{
		randomAngleX = FMath::RandRange(MinAngleTurning, MaxAngleTurning);
		randomAngleY = FMath::RandRange(MinAngleTurning, MaxAngleTurning);
	}
	else
	{
		randomAngleX = FMath::RandRange(MinAngleBranch, MaxAngleBranch);
		randomAngleY = FMath::RandRange(MinAngleBranch, MaxAngleBranch);
	}

	FRotator rotation; 

	// Rotation is applied in 2 dimensions if 3D mode is enabled. Otherwise it is just applied in the X dimension.
	if (bIs3DEnabled)
	{
		if (UKismetMathLibrary::RandomBool()) // Random boolean decides with equal chance whether the Y rotation will be forwards or backwards.
		{
			rotation = FRotator(-randomAngleX, randomAngleY, 0);
		}
		else
		{
			rotation = FRotator(-randomAngleX, -randomAngleY, 0);
		}
	}
	else
	{
		rotation = FRotator(-randomAngleX, 0, 0);
	}

	// Apply rotation to the lightning's direction.
	LightningDirection = rotation.RotateVector(LightningDirection);
}

// Save the state of the lightning.
void ALightningGenerator::Save()
{
	// Add to position and direction arrays/stacks.
	SavedDirections.Add(LightningDirection);
	SavedPositions.Add(DrawPosition);
}

// Return to previous lightning state.
void ALightningGenerator::Return()
{
	// Pop from position and direction arrays/stacks.
	LightningDirection = SavedDirections.Pop();
	DrawPosition = SavedPositions.Pop();
}

void ALightningGenerator::UpdateImGui()
{
	SCOPE_CYCLE_COUNTER(STAT_ImGui);
	{
		// Create ImGui window
		ImGui::Begin("Lightning Options", nullptr, ImGuiWindowFlags_AlwaysAutoResize);

		// Useful info
		ImGui::Text("FPS: %.1f", ImGui::GetIO().Framerate);
		ImGui::Text("Generation time (ms): %.3f", GenerationTime * 1000); // * 1000 to convert to milliseconds
		ImGui::Text("Render time (ms): %.3f", RenderTime * 1000);
		ImGui::Text("Segment count: %d", NumSegments);

		// Slider to scale ImGui window
		ImGui::SliderFloat("UI Scale", &ImGuiScale, 0.5, 4);
		ImGui::SetWindowFontScale(ImGuiScale);

		// Generator options
		if (ImGui::CollapsingHeader("Generator Options"))
		{
			ImGui::Indent();

			// Toggle physics model
			ImGui::Checkbox("Use physics model?", &bUsePhysicsModel);

			// Toggle 3D mode
			ImGui::Checkbox("3D Mode", &bIs3DEnabled);

			// Toggle auto generating lightning
			if (ImGui::Checkbox("Auto generate lightning?", &bAutoGenerate))
			{
				if (bAutoGenerate) // when re-enabled, spawn lightning to get the ball rolling again.
				{
					SpawnLightning();
				}
				else
				{
					SpawnTimerHandle.Invalidate(); // when disabled, disable timer.
				}
			}

			// If auto generate is true, show a slider to change how frequently it generates lightning.
			if (bAutoGenerate)
			{
				if (ImGui::SliderFloat("Spawn interval", &SpawnInterval, 0.1, 10))
				{
					if (SpawnInterval < ParticleLifespan) // Shorten the lifespan of lightning based on the spawn interval.
					{
						ParticleLifespan = SpawnInterval;
					}
				}
			}
			else
			{
				// If auto generate is off, pressing this button generates lightning.
				if (ImGui::Button("Generate lightning"))
				{
					SpawnLightning();
				}
			}

			// Pressing this button destroys the lightning particles.
			if (ImGui::Button("Destroy particles"))
			{
				DestroyParticles();
			}

			ImGui::Unindent();
		}

		// L-system options
		if (ImGui::CollapsingHeader("L-system Options"))
		{
			ImGui::Indent();

			// Re-build rule list, to be pressed when relevant values have been changed.
			if (ImGui::Button("Rebuild Rules"))
			{
				RebuildRules();
			}


			// Toggle animating lightning
			ImGui::Checkbox("Animate lightning", &bAnimateLightning);

			// Toggle using dynamic branch width
			ImGui::Checkbox("Dynamic branch width", &bDynamicBranchWidth);

			// If not using dynamic branch width, you can set fixed multiplier here.
			if (!bDynamicBranchWidth)
			{
				ImGui::SliderFloat("Branch width multiplier", &BranchWidthMultiplier, 0, 1);
			}

			// Sliders for L-system properties
			ImGui::SliderInt("Iterations", &Iterations, 1, 10);
			ImGui::SliderFloat("Branch chance (requires rules rebuild)", &BranchChance, 0, 1);
			ImGui::SliderFloat("Segment turn chance (requires rules rebuild)", &TurnChance, 0, 1);
			ImGui::SliderFloat("Min segment length", &MinSegmentLength, 1, 100);
			ImGui::SliderFloat("Max segment length", &MaxSegmentLength, 1, 100);
			ImGui::SliderFloat("Min branching angle", &MinAngleBranch, 0, 90);
			ImGui::SliderFloat("Max branching angle", &MaxAngleBranch, 0, 90);
			ImGui::SliderFloat("Min turning angle", &MinAngleTurning, 0, 90);
			ImGui::SliderFloat("Max turning angle", &MaxAngleTurning, 0, 90);
			ImGui::SliderFloat("Leader width", &MaxWidth, 1, 20);
			ImGui::SliderFloat("L-system jitter amount", &LSystemJitter, 0.05, 3);

			ImGui::Unindent();
		}

		// Physics model options
		if (ImGui::CollapsingHeader("Physics Model Options"))
		{
			ImGui::Indent();

			// Toggles a bug fix, intended only for use in the packaged build
			ImGui::Checkbox("Packeged Build Behaviour Fix", &PModel.bPackagedBuildFix);

			// If true, doesn't spawn the first segment particle
			ImGui::Checkbox("Hide first segment?", &bHideFirstSegment);

			// Toggles segment limit
			ImGui::Checkbox("Use segment limit?", &PModel.bUseSegmentLimit);

			// If segment limit is enabled, set the limit here
			if (PModel.bUseSegmentLimit)
			{
				ImGui::SliderInt("Segment limit", &PModel.MaxSegments, 0, 128);
			}

			// Sliders for physics model properties
			ImGui::SliderFloat("Scale", &PModel.Scale, 0, 50);
			ImGui::SliderFloat("Branch chance", &PModel.BranchChance, 0, 1);
			ImGui::SliderFloat("Voltage", &PModel.Voltage, 10000000, 500000000);
			ImGui::SliderFloat("Pressure multiplier", &PModel.PressureMultiplier, 0.1, 5.0);
			ImGui::SliderFloat("Constant A", &PModel.ConstantA, 0.01, 1);
			ImGui::SliderFloat("Constant A Deviation", &PModel.ConstantADeviation, 0, 1);
			ImGui::SliderFloat("Temperature at sea level (Kelvin)", &PModel.SeaLevelTemp, 273, 500);
			ImGui::SliderFloat("Start height", &PModel.StartHeight, 0, 5000);
			ImGui::SliderFloat("Base length", &PModel.Length, 0, 50);
			ImGui::SliderFloat("Base length deviation", &PModel.LengthDeviation, 0, 50);
			ImGui::SliderFloat("Branching angle", &PModel.Angle, 0, 90);
			ImGui::SliderFloat("Branching angle deviation", &PModel.AngleDeviation, 0, 90);
			ImGui::SliderFloat("Initial angle range", &PModel.InitialAngleRange, 0, 45);
			ImGui::SliderFloat("Model jitter amount", &PModelJitter, 0.05, 3);

			ImGui::Unindent();
		}

		// Shader options
		if (ImGui::CollapsingHeader("Shader Options"))
		{
			ImGui::Indent();

			// Particle sliders
			ImGui::SliderInt("Particle count", &ParticleCount, 1, 20);
			ImGui::SliderFloat("Particle lifespan", &ParticleLifespan, 0.1, 30);

			// Intensity of colour - the higher, the brighter
			ImGui::SliderFloat("Intensity", &ColorIntensity, 1, 1000);

			// Colour picker
			// *** //
			float color[4];
			color[0] = LightningColor.R;
			color[1] = LightningColor.G;
			color[2] = LightningColor.B;
			color[3] = LightningColor.A;

			ImGui::ColorPicker4("Colour", color);

			LightningColor = { color[0], color[1], color[2], color[3] };
			// *** //

			ImGui::Unindent();
		}

		if (ImGui::CollapsingHeader("Testing"))
		{
			ImGui::Indent();

			if (ImGui::Button("Test"))
			{
				Test100Times();
			}

			ImGui::Text("100 spawns time (ms): %.3f", Spawn100Times * 1000); // * 1000 to convert to milliseconds
			ImGui::Text("100 renders time (ms): %.3f", Render100Times * 1000);

			ImGui::Unindent();
		}

		ImGui::End();
	}
}

void ALightningGenerator::RebuildRules()
{
	// Empty current rule list.
	Rules.Empty();

	// Create rules using relative values.
	FString rule1 = "F => F (" + FString::SanitizeFloat(1 - BranchChance) + ")";
	FString rule2 = "F => F[+F] (" + FString::SanitizeFloat(BranchChance / 2) + ")";
	FString rule3 = "F => F[-F] (" + FString::SanitizeFloat(BranchChance / 2) + ")";
	FString rule4 = "F => FF (" + FString::SanitizeFloat(1 - TurnChance) + ")";
	FString rule5 = "F => F+F (" + FString::SanitizeFloat(TurnChance / 2) + ")";
	FString rule6 = "F => F-F (" + FString::SanitizeFloat(TurnChance / 2) + ")";
	
	// Add rules to array.
	Rules.Add(rule1);
	Rules.Add(rule2);
	Rules.Add(rule3);
	Rules.Add(rule4);
	Rules.Add(rule5);
	Rules.Add(rule6);
}

void ALightningGenerator::DestroyParticles()
{
	// If there are valid particles to destroy, destroy them. Also cancel the spawn timer.
	if (!SegmentParticles.IsEmpty())
	{
		for (UNiagaraComponent* particle : SegmentParticles)
		{
			if (IsValid(particle))
			{

				particle->DestroyComponent();
				//particle->DestroyInstance();
			}
		}

		SegmentParticles.Empty();
		SpawnTimerHandle.Invalidate();
	}
}

// Function for spawning lightning.
void ALightningGenerator::SpawnLightning()
{
	// Start time for calculating generation time.
	double start = FPlatformTime::Seconds();

	// If true, use physics method to generate lightning. If false, use L-system method.
	if (bUsePhysicsModel)
	{
		PModel.GenerateSegments();
	}
	else
	{
		DrawPosition = FVector(0, 0, 2000);
		System.Build(Axiom, Rules, Iterations);
	}

	// Format the L system's string for drawing.
	ReverseCharArray = System.GetResult().Reverse().GetCharArray();
	
	// Set default values for drawing L-system.
	SegmentsDrawn = 0;
	LightningDirection = FVector(0, 0, -1);

	// Count the number of segments that were generated based on the model.
	if (bUsePhysicsModel)
	{
		NumSegments = PModel.GetSegments().Num();
	}
	else
	{
		NumSegments = CountSegments();
	}
	
	// Set drawing to true so lightning draws in tick function.
	bIsDrawing = true;

	// End time and calculate how long it took to generate.
	double end = FPlatformTime::Seconds();
	GenerationTime = end - start;
}

void ALightningGenerator::Test100Times()
{
	Spawn100Times = 0;
	Render100Times = 0;

	for (int i = 0; i < 100; i++)
	{
		double start = FPlatformTime::Seconds();
		SpawnLightning();
		double end = FPlatformTime::Seconds();
		Spawn100Times += end - start;

		start = FPlatformTime::Seconds();
		Render();
		end = FPlatformTime::Seconds();
		Render100Times += end - start;

		DestroyParticles();
	}
}

// Called every frame
void ALightningGenerator::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

	// Update user interface.
	UpdateImGui();
	
	Render();
}

void ALightningGenerator::Render()
{
	// If there is something to draw...
	if (bIsDrawing)
	{
		// Start time for calculating render time.
		double start = FPlatformTime::Seconds();

		// If using the physics model...
		if (bUsePhysicsModel)
		{
			// Get segments.
			TArray<Segment> segments = PModel.GetSegments();

			if (!segments.IsEmpty())
			{

				// Iterate through the segments, creating a lightning particle for each of them.
				float mainSegmentWidth = segments[0].Diameter;
				for (Segment seg : segments)
				{
					if ((seg.StartPos != segments[0].StartPos && bHideFirstSegment) || !bHideFirstSegment)
					{
						UNiagaraComponent* lightningSegment = UNiagaraFunctionLibrary::SpawnSystemAtLocation(GetWorld(), LightningTemplate, FVector(0, 0, 0));
						lightningSegment->SetVectorParameter(FName("Start"), seg.StartPos);
						lightningSegment->SetVectorParameter(FName("End"), seg.EndPos);
						lightningSegment->SetIntParameter(FName("Particles"), ParticleCount);
						lightningSegment->SetFloatParameter(FName("MinWidth"), seg.Diameter * PModel.Scale);
						lightningSegment->SetFloatParameter(FName("MaxWidth"), seg.Diameter * PModel.Scale);
						FLinearColor finalColor = LightningColor * ColorIntensity * (seg.Diameter / mainSegmentWidth);
						lightningSegment->SetColorParameter(FName("Color"), finalColor);
						lightningSegment->SetFloatParameter(FName("Lifespan"), ParticleLifespan);
						lightningSegment->SetFloatParameter(FName("Jitter"), PModelJitter);
						lightningSegment->SetVectorParameter(FName("SphereScale"), SphereScale * seg.Diameter * PModel.Scale);
						lightningSegment->SetFloatParameter(FName("SphereLifespan"), ParticleLifespan - GetWorld()->GetDeltaSeconds() * SphereLifespanOffset);
						lightningSegment->SetVectorParameter(FName("SpherePos"), seg.EndPos);
						SegmentParticles.Add(lightningSegment);
					}
				}

			}

			// Nothing left to draw.
			bIsDrawing = false;

			// Set timer to generate next lightning strike if set to true.
			if (bAutoGenerate)
			{
				GetWorld()->GetTimerManager().SetTimer(SpawnTimerHandle, this, &ALightningGenerator::SpawnLightning, SpawnInterval, false);
			}
		}
		else
		{
			// The L-system lightning is drawn here. 

			// Exit condition for while loop.
			bool exit = false;

			// While the exit condition is not met...
			while (!exit)
			{
				// If the char array is not empty...
				if (!ReverseCharArray.IsEmpty())
				{
					// Pop the current char from the array.
					auto currentChar = ReverseCharArray.Pop();

					// Decide what to based on the current char.
					switch (currentChar)
					{
					case 'F': // Draw segment on 'F', increase no. of segments drawn tracker.
						DrawSegment();
						SegmentsDrawn++;
						break;
					case '+': // Rotate right on '+'.
						RotateRight();
						break;
					case '-': // Rotate left on '-'.
						RotateLeft();
						break;
					case '[': // Save lightning state on '['.
						Save();
						break;
					case ']': // Return to previous lightning state on ']'.
						Return();
						break;
					default:
						break;
					}

					// Once the required number of segments drawn for this frame has been reached, exit the loop.
					if (bAnimateLightning)
					{
						if (SegmentsDrawn == Speed)
						{
							exit = true;
							SegmentsDrawn = 0;
						}
					}
				}
				else
				{
					// Once the char array has been emptied, stop drawing and start the timer for spawning the next lightning strike.
					exit = true;
					bIsDrawing = false;
					if (bAutoGenerate)
					{
						GetWorld()->GetTimerManager().SetTimer(SpawnTimerHandle, this, &ALightningGenerator::SpawnLightning, SpawnInterval, false);
					}
				}
			}
		}

		// End time and calculate how long it took to render.
		double end = FPlatformTime::Seconds();
		RenderTime = end - start;
	}
}